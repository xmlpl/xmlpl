import xmlpl.xml;
import xmlpl.stdio;

string[] main(document in) {

	(: Retrieve the public and private interfaces from the XML Config file :)
	string private_interface = in/config/interface[@type == "private"]/@device;
	string public_interface = in/config/interface[@type == "public"]/@device;

	(: Output the header for the BASH shell script :)
	print ("#!/bin/bash\n");
	print ("# This script was automatically generated by iptables_gen\n\n");
	print ("# Define public and private interfaces\n");

	(: Check if the public and private interfaces are defines :)
	if (private_interface == null) {
		warn("private interface undefined!");
	} else {
		print ("PRIVATE=\"" + private_interface + "\"\n");
	}

	if (public_interface == null) {
		error ("public interface undefined!");
		return;
	} else {
		print ("PUBLIC=\"" + public_interface + "\"\n");
	}

	(: Store IP address of public interface in shell variable :)
	if ( in/config/rules/reverse ) {	
		print ("\n# Lookup IP address of public interface\n");
		print ("PUBLIC_IP=`/sbin/ifconfig ${PUBLIC} | grep \"inet addr\" | awk '{match($0,\/inet addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+\/); print substr($0,RSTART+10, RLENGTH-10); }'`\n");
	}

	(: Clear all currently active iptables rules :)
	print ("\n# Flush the current iptables rules\n");
	print ("iptables -t filter --flush\n");
	print ("iptables -t nat --flush\n\n");

	(: Process filter rules
	 : this code loops over all filter rules defined in
	 : the XML configuration file and generates cooresponding
	 : iptables commands. :)
	print ("# Apply filter rules\n");
	foreach ( in/config/rules/filter ) {
		string scope = ./@scope;
		string action = ./@action;
		string default_action = ./@default_action;
		string host = ./@host;
		string port = ./@port;

		if (scope == null) {
			error("no scope defined for filter rule:  ");
			continue;
		}

		if (default_action != null ) {
			continue;
		}

		if (action == null) {
			error("no action defined for filter rule:  ");
			continue;
		}

		string rule_options;

		if (scope == "public") {
			rule_options = "-i ${PUBLIC} ";
		} else if (scope == "private") {
			rule_options = "-i ${PRIVATE} ";
		} else {
			error("Invalid scope specified for rule:  ");
			continue;
		}

		if (host != null) {
			rule_options += "--source " + host + "/32 ";
		}
		if (port != null) {
			rule_options += "--dport " + port + " ";
			rule_options += "-j " + action;
			print ("iptables -t filter --append INPUT -p tcp -m tcp " + rule_options + "\n");
			print ("iptables -t filter --append INPUT -p udp -m udp " + rule_options + "\n");
		} else {
			rule_options += "-j " + action;
			print ("iptables -t filter --append INPUT " + rule_options + "\n");
		}
	}

	(: Process NAT rule
	 : this reads the NAT rule from the XML configuration file
	 : and output required iptables rules to the shell script
	 : to implement NAT :)
	string enable_nat = in/config/rules/nat/@enable;
	if (enable_nat != null && enable_nat == "true") {
		if ( private_interface == null) {
			error("Private interface must be defined before enabling NAT!");
			return;
		}

		print("\n# Enable Network Address Translation from private network using public interface\n");
		print("iptables -t nat --append POSTROUTING -o ${PUBLIC} -j MASQUERADE\n");
		print("iptables -t filter --append FORWARD -i ${PRIVATE} -o ${PUBLIC} -j ACCEPT\n");
		print("iptables -t filter --append FORWARD -m state -i ${PUBLIC} -o ${PRIVATE} --state ESTABLISHED,RELATED -j ACCEPT\n\n");
	}

	(: Process reverse rules
	 : loop through each reverse rule, outputting
	 : the appropriate iptables commands to the 
 	 : shell script :)
	print ("# Apply reverse mapping rules\n");
	foreach ( in/config/rules/reverse ) {
		string public_port = ./@public_port;
		string target_host = ./@target_host;
		string target_port = ./@target_port;
	
		if (public_port == null) {
			error("No public_port specified in reverse rule:");
			return;
		}
		if (target_host == null) {
			error("No target_host specified in reverse rule:");
			return;
		}
		if (target_port == null) {
			error("No target_port specified in reverse rule:");
			return;
		}

		string tcp_rule1 = "iptables -t nat --append PREROUTING -p tcp -m tcp -d ${PUBLIC_IP} --dport " + public_port + " -j DNAT --to-destination " + target_host + ":" + target_port + "\n";
		string tcp_rule2 = "iptables -t filter --append FORWARD -p tcp -m tcp -d " + target_host + " --dport " + target_port + " -j ACCEPT\n";
		string udp_rule1 = "iptables -t nat --append PREROUTING -p udp -m udp -d ${PUBLIC_IP} --dport " + public_port + " -j DNAT --to-destination " + target_host + ":" + target_port + "\n";
		string udp_rule2 = "iptables -t filter --append FORWARD -p udp -m udp -d " + target_host + " --dport " + target_port + " -j ACCEPT\n";

		print (tcp_rule1);
		print (tcp_rule2);
		print (udp_rule1);
		print (udp_rule2);
	}		

	(: Process remap rules
	 : loop through each remap rule, outputting
	 : the appropriate iptables commands to the 
 	 : shell script :)
	print ("\n# Apply URL remap rules\n");
	foreach ( in/config/rules/remap ) {
		string source_url = ./@source_url;
		string target_url = ./@target_url;

		if (source_url == null) {
			error("No source_url specified in remap rule:");
			return;
		}
		if (target_url == null ) {
			error("No target_url specified in remap rule:");
			return;
		}
		if (in/config/rules/nat/@enable != "true") {
			error("NAT must be enabled for remap rules!");
			continue;
		}

		string target_addr = "TARGET_ADDR=`dig +short " + target_url + " | awk ' /[0-9]+.[0-9]+.[0-9]+.[0-9]+/ { print $0 }' | head -1`\n";
		string forward_rule = "iptables -t nat --append PREROUTING -d " + source_url + " -j DNAT --to-destination ${TARGET_ADDR}\n";

		print ( target_addr );
		print ( forward_rule );

	}

	(: These rules are appended to the tail end of the shell script
	 : and set the default actions to take if a packet is not matches
	 : by a rule. :)
	print("\n# Set default iptables actions\n");
	print ("iptables -t filter --append INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT \n");

	if (private_interface != null) {
		print ("iptables -t filter --append FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT \n");
		print ("iptables -t filter --append FORWARD -i ${PUBLIC} -j DROP \n");
		print ("iptables -t filter --append FORWARD -i ${PRIVATE} -m state --state NEW,ESTABLISHED -j ACCEPT \n");
	}

	string default_action = in/config/rules/@default_action;
	if ( default_action != null ) {
		if (default_action == "ACCEPT") {
			print ("iptables -t filter --append INPUT -m state --state NEW,ESTABLISHED -j ACCEPT\n");
		} else {
			print ("iptables -t filter --append INPUT -j DROP \n");
		} 
	} else {
		print ("iptables -t filter --append INPUT -j DROP \n");
	} 

	print ("iptables -t filter --append OUTPUT -m state --state NEW,ESTABLISHED -j ACCEPT \n");
	
}
